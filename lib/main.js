// Generated by CoffeeScript 1.6.3
(function() {
  var BAP, Line_by_line, TRM, TYPES, alert, badge, coffee, debug, echo, help, info, log, njs_fs, njs_path, rpr, warn, whisper;

  njs_fs = require('fs');

  njs_path = require('path');

  BAP = require('coffeenode-bitsnpieces');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'scratch';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  coffee = require('coffee-script');

  Line_by_line = require('line-by-line');

  this.aux = {};

  this.main = function() {

    /* The `main` routine collects the command name and command parameters from the environment
     */
    var command, message, method_name, parameter, parameters, texroute;
    texroute = process.argv[2];
    command = process.argv[3];
    parameter = process.argv[4];

    /* TAINT we naïvely split on comma, which is not robust in case e.g. string or list literals contain
    that character. Instead, we should be doing parsing (eg. using JSON? CoffeeScript expressions /
    signatures?)
     */
    parameters = parameter.split(',');
    method_name = command.replace(/-/g, '_');
    info("©44 texroute: " + (rpr(texroute)));
    info("©45 argv: " + (rpr(process.argv)));
    info("©46 command: " + (rpr(command)) + ", parameter: " + (rpr(parameter)));
    if (this[method_name] == null) {
      message = "Unknown command: " + (rpr(command));
      warn(message);
      debug(message);
      return null;
    }
    this.read_aux(texroute, (function(_this) {
      return function(error) {
        var R;
        if (error != null) {
          throw error;
        }
        warn(_this.aux);
        if ((R = _this[method_name].apply(_this, parameters)) != null) {
          return echo(R);
        }
      };
    })(this));
    return null;
  };

  this.read_aux = function(texroute, handler) {
    var auxroute, labels, last_idx, postprocess;
    last_idx = texroute.length - 1 - (njs_path.extname(texroute)).length;
    auxroute = texroute.slice(0, +last_idx + 1 || 9e9).concat('.auxcopy');
    this.aux['labels'] = labels = {};
    this._lines_of(auxroute, (function(_this) {
      return function(error, line, line_nr) {
        var ignore, label, match, name, pageref, ref, source, title, type, unknown, value, x;
        if (error != null) {
          return handler(error);
        }
        if (line === null) {
          postprocess();
          return handler(null);
        }

        /* De-escaping characters: */
        line = line.replace(_this.read_aux.protectchar_matcher, function($0, $1) {
          return String.fromCharCode(parseInt($1, 16));
        });

        /* Compiling and evaluating CoffeeScript: */
        if ((match = line.match(_this.read_aux.coffeescript_matcher)) != null) {
          try {
            source = coffee.compile(match[1], {
              'bare': true,
              'filename': auxroute
            });
            x = eval(source);
          } catch (_error) {
            error = _error;
            warn("unable to parse line " + line_nr + " of " + auxroute + ":");
            warn(line);
            warn(rpr(error));
            return null;
          }
          switch (type = TYPES.type_of(x)) {
            case 'pod':
              for (name in x) {
                value = x[name];
                _this.aux[name] = value;
              }
              break;
            default:
              warn("ignoring value of type " + type + " on line " + line_nr + " of " + auxroute + ":\n" + (rpr(line)));
          }
          return null;
        }

        /* Parsing labels and references: */
        if ((match = line.match(_this.read_aux.newlabel_matcher)) != null) {
          ignore = match[0], label = match[1], ref = match[2], pageref = match[3], title = match[4], unknown = match[5], unknown = match[6];
          labels[label] = {
            name: label,
            ref: parseInt(ref, 10),
            pageref: parseInt(pageref, 10),
            title: title
          };
          return null;
        }
      };
    })(this));
    postprocess = (function(_this) {
      return function() {

        /* Postprocessing of the data delivered by the `\auxgeo` command.
        
        All resulting lemgths are in millimeters. `firstlinev` is the distance between the
        top of the paper and the top of the first line of text. Similarly, the implicit 1 inch distance in
        `\voffset` and `\hoffset` is being made explicit so that the reference point is shifted to the paper's
        top left corner.
        
        See http://www.ctex.org/documents/packages/layout/layman.pdf p9 and
        http://en.wikibooks.org/wiki/LaTeX/Page_Layout
         */
        var g, name, one_inch, value;
        one_inch = 4736286;
        if ((g = _this.aux['geometry']) != null) {
          for (name in g) {
            value = g[name];
            if (name === 'voffset') {
              value += one_inch;
            }
            if (name === 'hoffset') {
              value += one_inch;
            }
            g[name] = value / 27597261 * 148.5;
          }
          return g['firstlinev'] = g['voffset'] + g['topmargin'] + g['headsep'] + g['headheight'];
        }
      };
    })(this);
    return null;
  };


  /* matcher for those uber-verbosely: `\protect \char "007B\relax` escaped characters: */

  this.read_aux.protectchar_matcher = /\\protect\s+\\char\s+"([0-9A-F]+)\\relax\s?/g;


  /* matcher for CoffeeScript: */

  this.read_aux.coffeescript_matcher = /^%\s+coffee\s+(.+)$/;


  /* \newlabel{otherlabel}{{2}{3}} */


  /* \newlabel{otherlabel}{{2}{3}{References}{section.2}{}} */


  /* TAINT not sure whether this RegEx is backtracking-safe as per
    http://www.regular-expressions.info/catastrophic.html
   */

  this.read_aux.newlabel_matcher = /^\\newlabel\{([^{}]+)\}\{\{([0-9]*)\}\{([0-9]*)\}(?:\{([^{}]*)\}\{([^{}]*)\}\{([^{}]*)\})?\}$/;

  this._lines_of = function(route, handler) {
    var line_nr, line_reader;
    line_nr = 0;
    line_reader = new Line_by_line(route);
    line_reader.on('error', (function(_this) {
      return function(error) {
        return handler(error);
      };
    })(this));
    line_reader.on('end', (function(_this) {
      return function() {
        return handler(null, null);
      };
    })(this));
    line_reader.on('line', (function(_this) {
      return function(line) {
        line_nr += 1;
        return handler(null, line, line_nr);
      };
    })(this));
    return null;
  };

  this.debug = function(message) {
    return echo("\\textbf{\\textcolor{red}{" + (this.escape(message)) + "}}");
  };

  debug = this.debug.bind(this);

  this.page_and_line_nr = function(page_nr, line_nr) {
    page_nr = parseInt(page_nr, 10);
    line_nr = parseInt(line_nr, 10);
    return "Helo from NodeJS.\nThis paragraph appears on page " + page_nr + ", column ..., line " + line_nr + ".";
  };

  this._escape_replacements = [[/\\/g, '\\textbackslash{}'], [/\{/g, '\\{'], [/\}/g, '\\}'], [/&/g, '\\&'], [/\$/g, '\\$'], [/\#/g, '\\#'], [/%/g, '\\%'], [/_/g, '\\_'], [/\^/g, '\\textasciicircum{}'], [/~/g, '\\textasciitilde{}']];

  this.escape = function(text) {
    var R, matcher, replacement, _i, _len, _ref, _ref1;
    R = text;
    _ref = this._escape_replacements;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], matcher = _ref1[0], replacement = _ref1[1];
      R = R.replace(matcher, replacement);
    }
    return R;
  };

  this.main();

}).call(this);
